import asyncio
import threading
import time

from fastapi import APIRouter

"""
注意：不建议再异步操作中使用同步函数，导致堵塞。

---

同步路由中，每个请求是多线程去执行的。异步路由是单线程去执行的，那为什么处理大量请求的时候用异步路由呢？？？

虽然异步路由在 FastAPI 中是由单线程执行的，但它在处理大量请求时依然具有性能上的优势。这是因为异步代码利用了事件循环（event loop）和协程（coroutine）的机制，能够在等待外部资源的同时继续执行其他任务，而不会被阻塞。以下是一些关键的原因：

非阻塞 I/O： 异步路由主要用于处理涉及大量 I/O 操作的场景，如数据库查询、网络请求等。在等待这些外部资源返回的过程中，事件循环能够切换到执行其他任务，而不会等待阻塞。

高并发： 单线程异步模型通过事件循环的方式能够高效处理大量并发请求。在同一时间点，一个线程可以管理多个协程，从而实现高并发性能，而不需要为每个请求创建一个新的线程，减少了线程切换的开销。

资源利用率： 异步代码更有效地利用系统资源，因为它减少了线程和进程之间的切换开销。在同步模型中，为每个请求分配一个线程可能导致系统资源的枯竭，而异步模型可以更有效地管理这些资源。

响应时间： 异步路由通常能够更快地响应请求，特别是在处理大量并发请求时。由于异步模型的非阻塞特性，它可以更快地完成对外部资源的访问，从而提高整体的响应速度。

总体而言，异步路由在处理高并发和I/O密集型任务时能够提供更好的性能和资源利用率。然而，具体的选择还取决于应用的性质和需求。在某些情况下，同步路由可能仍然是一个合适的选择，尤其是对于较小规模的应用。

---

在异步编程中，切换到执行其他任务通常发生在等待非阻塞操作完成的时候。异步框架使用事件循环来管理任务的执行，当一个任务在等待外部资源（例如 I/O 操作、网络请求、数据库查询等）时，事件循环会将控制权切换到另一个可执行的任务，而不是等待阻塞。

这种非阻塞的等待和切换是通过使用协程（coroutine）来实现的。协程是可以在执行过程中暂停和恢复的函数，允许在等待异步操作时让出执行权。当一个协程等待一个 I/O 操作时，事件循环可以继续执行其他协程，而不会阻塞整个线程。

在 FastAPI 中，使用 async def 声明的异步路由函数是协程，而 await 关键字用于等待异步操作完成。当执行到 await 语句时，如果发现需要等待的操作没有完成，事件循环会切换到执行其他可等待的任务。
"""

sty_route_app = APIRouter(prefix="/sty_route_app", tags=["同步、异步路由学习"])


@sty_route_app.get("/sync")
def sync_function():
    time.sleep(20)
    print("当前同步函数运行的线程ID：", threading.current_thread().ident)
    return {"index": "sync"}


@sty_route_app.get("/async")
async def async_function():
    print("Received request")
    await asyncio.sleep(10)  # 等待异步操作完成
    return {"message": "Hello, World!"}
